{"version":3,"sources":["node_modules/quickselect/quickselect.js","node_modules/rbush/index.js","js/labelgun.min.js"],"names":["e","t","exports","module","require","define","amd","labelgun","rbush","l","a","n","i","call","m","c","d","o","Object","defineProperty","configurable","enumerable","get","__esModule","default","prototype","hasOwnProperty","p","s","TypeError","value","length","writable","key","r","tree","allLabels","hasChanged","allChanged","hideLabel","showLabel","keys","state","_total","push","_getLabelsByState","Error","JSON","stringify","search","indexOf","splice","clear","forEach","_callLabelStateCallback","orderedLabels","map","sort","_compare","_allLower","isDragged","id","weight","_handleLabelIngestion","ingestLabel","bottomLeft","minX","minY","topRight","maxX","maxY","labelObject","name","_setupLabels","_compareLabels","_callLabelCallbacks","remove","insert","removeLabel","_addToTree"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACljBA,CAAC,UAASA,CAAT,EAAWC,CAAX,EAAa;AAAC,sBAAiBC,OAAjB,yCAAiBA,OAAjB,MAA0B,oBAAiBC,MAAjB,yCAAiBA,MAAjB,EAA1B,GAAkDA,OAAOD,OAAP,GAAeD,EAAEG,QAAQ,OAAR,CAAF,CAAjE,GAAqF,cAAY,OAAOC,MAAnB,IAA2BA,OAAOC,GAAlC,GAAsCD,OAAO,CAAC,OAAD,CAAP,EAAiBJ,CAAjB,CAAtC,GAA0D,oBAAiBC,OAAjB,yCAAiBA,OAAjB,KAAyBA,QAAQK,QAAR,GAAiBN,EAAEG,QAAQ,OAAR,CAAF,CAA1C,GAA8DJ,EAAEO,Q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","file":"labelgun.min.f24433a5.map","sourceRoot":"..","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"rbush\")):\"function\"==typeof define&&define.amd?define([\"rbush\"],t):\"object\"==typeof exports?exports.labelgun=t(require(\"rbush\")):e.labelgun=t(e.rbush)}(this,function(e){return function(e){function t(l){if(a[l])return a[l].exports;var n=a[l]={i:l,l:!1,exports:{}};return e[l].call(n.exports,n,n.exports,t),n.l=!0,n.exports}var a={};return t.m=e,t.c=a,t.d=function(e,a,l){t.o(e,a)||Object.defineProperty(e,a,{configurable:!1,enumerable:!0,get:l})},t.n=function(e){var a=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(a,\"a\",a),a},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=\"\",t(t.s=0)}([function(e,t,a){\"use strict\";function l(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(t,\"__esModule\",{value:!0});var n=function(){function e(e,t){for(var a=0;a<t.length;a++){var l=t[a];l.enumerable=l.enumerable||!1,l.configurable=!0,\"value\"in l&&(l.writable=!0),Object.defineProperty(e,l.key,l)}}return function(t,a,l){return a&&e(t.prototype,a),l&&e(t,l),t}}(),i=a(1),s=function(e){return e&&e.__esModule?e:{default:e}}(i),r=function(){function e(t,a,n){l(this,e);var i=n||10;this.tree=(0,s.default)(i),this.allLabels={},this.hasChanged=[],this.allChanged=!1,this.hideLabel=t,this.showLabel=a}return n(e,[{key:\"_total\",value:function(e){for(var t=0,a=0,l=Object.keys(this.allLabels);a<l.length;a++)this.allLabels[l[a]].state==e&&(t+=1);return t}},{key:\"totalShown\",value:function(){return this._total(\"show\")}},{key:\"totalHidden\",value:function(){return this._total(\"hide\")}},{key:\"_getLabelsByState\",value:function(e){for(var t=[],a=0,l=Object.keys(this.allLabels);a<l.length;a++)this.allLabels[l[a]].state==e&&t.push(this.allLabels[l[a]]);return t}},{key:\"getHidden\",value:function(){return this._getLabelsByState(\"hide\")}},{key:\"getShown\",value:function(){return this._getLabelsByState(\"show\")}},{key:\"getCollisions\",value:function(e){var t=this.allLabels[e];if(void 0===t)throw Error(\"Label doesn't exist :\"+JSON.stringify(e));var a=this.tree.search(t),l=a.indexOf(t);return void 0!==l&&a.splice(l,1),a}},{key:\"getLabel\",value:function(e){return this.allLabels[e]}},{key:\"reset\",value:function(){this.tree.clear(),this.allLabels={},this.hasChanged=[],this.allChanged=!1}},{key:\"_callLabelCallbacks\",value:function(e){var t=this;Object.keys(this.allLabels).forEach(function(a){t._callLabelStateCallback(t.allLabels[a],e)})}},{key:\"_callLabelStateCallback\",value:function(e,t){var a=t||e.state;\"show\"===a&&this.showLabel(e),\"hide\"===a&&this.hideLabel(e)}},{key:\"_compareLabels\",value:function(){var e=this;this.orderedLabels=Object.keys(this.allLabels).map(function(t){return e.allLabels[t]}).sort(this._compare),this.orderedLabels.forEach(function(t){var a=e.tree.search(t);(0===a.length||e._allLower(a,t)||t.isDragged)&&(e.allLabels[t.id].state=\"show\")})}},{key:\"_allLower\",value:function(e,t){for(var a=void 0,l=0;l<e.length;l++)if(a=e[l],\"show\"===a.state||a.weight>t.weight||a.isDragged)return!1;return!0}},{key:\"_compare\",value:function(e,t){return e.weight>t.weight?-1:e.weight<t.weight?1:0}},{key:\"_setupLabels\",value:function(){var e=this;this.allChanged?(this.allChanged=!1,this.hasChanged=[],this.tree.clear(),Object.keys(this.allLabels).forEach(function(t){e._handleLabelIngestion(t)})):this.hasChanged.length>0&&(this.hasChanged.forEach(function(t){e._handleLabelIngestion(t)}),this.hasChanged=[])}},{key:\"_handleLabelIngestion\",value:function(e){var t=this.allLabels[e];this.ingestLabel({bottomLeft:[t.minX,t.minY],topRight:[t.maxX,t.maxY]},t.id,t.weight,t.labelObject,t.name,t.isDragged)}},{key:\"update\",value:function(e){this.allChanged=!e,this._setupLabels(),this._compareLabels(),this._callLabelCallbacks()}},{key:\"removeLabel\",value:function(e){var t=this.allLabels[e];this.tree.remove(t),delete this.allLabels[e]}},{key:\"_addToTree\",value:function(e){this.allLabels[e.id]=e,this.tree.insert(e)}},{key:\"ingestLabel\",value:function(e,t,a,l,n,i){if(void 0!==a&&null!==a||(a=0),!e||!e.bottomLeft||!e.topRight)throw Error(\"Bounding box must be defined with bottomLeft and topRight properties\");if(\"string\"!=typeof t&&\"number\"!=typeof t)throw Error(\"Label IDs must be a string or a number\");var s=this.allLabels[t];s&&this.removeLabel(s.id);var r={minX:e.bottomLeft[0],minY:e.bottomLeft[1],maxX:e.topRight[0],maxY:e.topRight[1],state:\"hide\",id:t,weight:a,labelObject:l,name:n,isDragged:i};this._addToTree(r)}},{key:\"labelHasChanged\",value:function(e){-1===this.hasChanged.indexOf(e)&&this.hasChanged.push(e)}}]),e}();t.default=r},function(t,a){t.exports=e}])});"]}